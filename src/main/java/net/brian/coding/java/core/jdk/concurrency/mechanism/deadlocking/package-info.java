/**
 * 只要破坏死锁 4 个必要条件之一中的任何一个，死锁问题就能被解决。具体解决思路如下：
 * 1、最简单、最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程；
 * 2、撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；
 * 或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程
 * 比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素；
 * 3、进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。
 * 虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的。
 * 
 * 分析死锁的方式方法：
 * 我们需要查看Java应用程序的线程转储。线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储（dump文件）
 * Linux下，kill -3 PID 
 * （1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java
 * （2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid windows下，按 Ctrl + Break 来获取
 * 
 * 死锁常见场景： 资源池死锁：资源池通常采用信号量实现当资源池为空时的阻塞行为。
 * 饥饿线程死锁：一个任务提交另一个任务，并等待被提交任务在单线程的Executor中执行完成。则第一个任务永远等待下去
 * 
 */

package net.brian.coding.java.core.jdk.concurrency.mechanism.deadlocking;